---
title: Wallet Custody & Trusted Execution Enclave
description: Architecture and lifecycle of Surge's self-custodial wallet leveraging hardware-isolated Trusted Execution Environments (TEE) for key generation, signing, attestation, and verifiable self-custody.
---
import ZoomImage from "../../components/ZoomImage";

# üîê Wallet Custody & Trusted Execution Enclave

The user wallet custody implements a **self-custodial design** that isolates all cryptographic key operations within a hardware backed **Trusted Execution Environment (TEE)**.  
This approach follows an institutional-grade security model similar to Coinbase‚Äôs enclave based wallet infrastructure, providing deterministic isolation and remote attestation guarantees.

The enclave executes as a sealed runtime within the underlying host infrastructure (GCP Confidential Computing).  
Once instantiated, its memory and code are cryptographically measured and isolated even operators, administrators, or the host kernel cannot read, export, or modify a user‚Äôs private key.

<ZoomImage
  src="/assets/enclave_arch.png"
  alt="Secure Enclave Architecture"
  width="100%"
  className="mx-auto"
/>

## Authentication & Key Lifecycle

### 1. Email Login & Session Initialization
- The user authenticates using **email + OTP**.  
- Upon successful verification, a short-lived **JWT session token**.  
- This token is used to authorize enclave operations during its validity period.

### 2. Deterministic Key Generation in TEE
- On first login, the instance queries the enclave for an existing keypair.  
- If absent, the enclave **generates a new asymmetric keypair** internally.  
- The **public key** is returned and mapped as `{ userID, email, publicKey }`.  
- The **private key** remains sealed inside enclave memory, never exposed or serialized outside the boundary.

### 3. Transaction Signing Flow
- The client submits a transaction payload with the active JWT.  
- The backend validates the session and relays `{ userID, txData, signatureRequestID }` to the enclave.  
- The enclave verifies request authenticity and authorization before signing.  
- Signing is executed inside the isolated enclave runtime using the internal key material.  
- The resulting signature is returned, the key never leaves secure memory.

### 4. Controlled Key Export
- Users may optionally export their private key for external self-custody.  
- The backend re-prompts for OTP, then issues an export command to the enclave.  
- The enclave decrypts and returns the key encrypted.  

## Self-Custody Model

| Property | Enforcement |
|-----------|-------------|
| **Key Isolation** | Enforced by hardware boundary, inaccessible to OS or provider. |
| **User Sovereignty** | Signing only under valid JWT session Controlled by the user. |
| **Immutability** | Enclave code and memory are sealed post-deployment. |

> The enclave acts as a hardware root of trust ensuring keys exist, operate independently of any application-layer control.


## Attestation & Integrity Proofs

Each TEE instance produces a cryptographic attestation report during initialization:
- Verifies the enclave runs on genuine, unmodified hardware
- The backend validates this attestation before any signing or export operations.  
- If code or environment changes, the attestation fingerprint differs and trust is revoked automatically.

This mechanism provides verifiable proof that the wallet enclave is authentic, unmodified, and operating in a known-good state.

## Versioning & Update Lifecycle

Enclave binaries are immutable at runtime. Updates or bug fixes require a versioned redeploy process:
1. Build a new enclave image (with updated wallet logic).
2. Deploy and verify its new measurement hash via attestation.
